<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maquetación con CSS Grid</title>
    <link rel="stylesheet" href="./css/grid.css">
</head>

<body>

    <main>
        <center>
            <h1 style="color: red;">Grid</h1>
        </center>
        <p style="font-size: 20px;"><b>CSS grid</b> es un sistema de maquetación basado en grillas y se caracteriza por
            ser bidimensional, independiente
            del orden del markup y flexible. Extremadamente flexible.</p>

        <div>
            <h1>Ejercicio 1: </h1>
            <p>En el CSS de la clase container decimos a este elemento que su modo display es grid. Lo que quiere decir
                que
                los hijos inmediatamente descendientes serán parte de la grilla.</p>

            <p>El siguiente punto importante es grid-gap: 1rem. Esta línea lo que hace es incluir un "gutter" o canal
                de rejilla de 1rem para separar los elementos de la grilla. La unidad rem es un tamaño que se basa en el
                tamaño base de la letra m. Se usa comunmente para maquetar de una forma más flexible, dado que con
                modificar el tamaño de la fuente base todo el contenido se adaptaría en concordancia con en el tamaño
                base.</p>

            <p>Con grid-template-columns lo que hacemos es definir el número de columnas y el ancho de las mismas. En
                este caso se han definido 3 columnas de 200px cada una.</p>

            <p>Con grid-template-rows más de lo mismo, solo que esta vez estamos definiendo el número de filas. En
                nuestro ejemplo hemos definido 2 filas de 150px cada una. Además, el algoritmo que usa grid es lo
                suficiente inteligente como para colocar de forma esperada elementos extra, como es nuestro caso, ya que
                hemos definido 2 filas pero hemos incluido un séptimo elemento que se coloca en una tercera fila no
                definida. Y su altura (al no estar especificada) sería la que ocupase el contenido de la celda. </p>
        </div>
        <center>
            <div class="container1">
                <div>1</div>
                <div>2</div>
                <div>3</div>
                <div>4</div>
                <div>5</div>
                <div>6</div>
                <div>7</div>
            </div>
        </center>

        <div>
            <h1>Ejercicio 2: Colocar elementos en la grilla </h1>

            <p>podemos hacer uso de grid-column-start y grid-column-end para colocar elementos en un línea de columna o
                grid-row-start y grid-row-end para las filas. O también podemos hacer uso del método acortado
                grid-column: X / Y; y grid-row: X / Y; siendo X e Y el número de columna o fila inicial y el final.</p>
        </div>

        <center>
            <div class="container2">
                <div class="item-a">
                    <img src="https://picsum.photos/300/600/?random">
                </div>
                <div>
                    <img src="https://picsum.photos/600/300/?random">
                </div>
                <div class="item-b">
                    <img src="https://picsum.photos/200/200/?random">
                </div>
                <div>
                    <img src="https://picsum.photos/200/500/?random">
                </div>
                <div class="item-c">
                    <img src="https://picsum.photos/200/400/?random">
                </div>
                <div>
                    <img src="https://picsum.photos/200/250/?random">
                </div>
                <div>
                    <img src="https://picsum.photos/200/100/?random">
                </div>
                <div class="item-d">
                    <img src="https://picsum.photos/200/600/?random">
                </div>
            </div>
        </center>

        <div>
            <h1>Ejercicio 3: Layouts con grid-template-areas </h1>

            <p>CSS Grid no solamente permite hacer de nuestra maquetación más flexible, sino que además es un motor muy
                potente para diseñar layouts en dos dimensiones. Por ejemplo veamos uno de los layouts más usados a lo
                largo de la web. El denominado holy grail:</p>

            <p>Con los estilos que acabamos de aplicar especificamos un máximo de ancho de 1000px. Es recomendable hacer
                uso del max-width dado que en monitores especialmente grandes no queremos que el ancho de la web sea el
                total del mismo.</p>

            <p>También especificamos un mínimo de altura con vh (Viewport Height). Esto hará que aunque no tengamos
                mucho contenido en nuestra sección de contenido nos aseguramos que el footer queda abajo del todo. Si lo
                quitásemos quedaría tal que así:
            </p>

            <p>
                si nos fijamos atentamente veremos un nueva unidad: fr. Esta unidad de medida es propia de CSS Grid e
                indica que un elemento debería ocupar una fracción determinada del espacio restante.
            </p>

            <p>
                Lo bueno de fr es que tiene en cuenta el tamaño de los elementos de la grilla por lo que si tenemos dos
                columnas y la primera hemos dicho que ocupe 100px y la segunda 1fr la segunda columna ocupará 100% -
                100px.
            </p>

            <p>
                La pregunta ahora es la siguiente: ¿Cómo reordenamos los elementos? Es aquí donde entran en juego
                grid-template-areas y grid-area.
                A cada sección de nuestra web le asignamos un grid-area. El nombre del grid-area puede ser el que
                queramos. Y la magia la veremos en el contenedor (main) con grid-template-areas.
            </p>
        </div>

        <center>
            <div class="container3">
                <header>Header</header>
                <nav>Nav</nav>
                <section>Section</section>
                <aside>Aside</aside>
                <footer>Footer</footer>
            </div>
        </center>

        <div>
            <h1>Ejercicio 4: </h1>
            <p>
                Dentro del media query hemos redefinido el número de columnas y filas. Por último reordenamos los
                elementos especificando una nueva distribución con grid-template-areas.
            </p>

            <p>
                por último nos queda el media query para desktop
            </p>
        </div>

        <center>
            <div class="container4">
                <header>Header</header>
                <nav>Nav</nav>
                <section>Section</section>
                <aside>Aside</aside>
                <footer>Footer</footer>
            </div>
        </center>

        <div>
            <h1>Ejercicio 5: Repeat </h1>
            <p>
                con grid-template-columns si quiero crear una grilla de 12 columnas tendría que hacerlo tal que así:

                <b>grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr;</b>
            </p>
            <p>
                Pues no, dado que tenemos la función repeat(), cuyo primer argumento es el número de repeticiones y el
                segundo argumento es la unidad a repetirse: 1
                <b>grid-template-columns: repeat(12, 1fr);</b>
            </p>
            <p>
                la belleza de CSS Grid es que podremos crear las columnas y filas a nuestro antojo y bajo demanda.
            </p>

            <p>
                No tendría absolutamente ninguna diferencia visual. Esto no quiere decir que ya no sea necesario un
                sistema de grillas de un número determinado de
                columnas, lo que quiere decir es que tenemos la libertad de elegir el número de columnas y filas
                dependiendo del diseño.
            </p>
        </div>

        <center>
            <div class="container5">
                <header>Header</header>
                <nav>Nav</nav>
                <section>Section</section>
                <aside>Aside</aside>
                <footer>Footer</footer>
            </div>
        </center>

        <div>
            <h1>Ejercicio 6: Responsividad avanzada</h1>

            <p>
                Esto lo podremos hacer con auto-fit. Queremos que las celdas ocupen 200px y que se coloquen en una fila
                siempre y cuando haya espacio.
            </p>
            <p>
                De esta forma el número de elementos será dinámico, contando que haya 200px libres. Pero el problema
                ahora es que van a quedar espacios en blanco en ciertos puntos:
            </p>
            <p>
                Por esta razón tenemos minmax(); una función que especifica un mínimo y un máximo. Nuestro mínimo en
                este caso serían 200px y el máximo sería 1fr, de esta forma si hay menos de 200px libres los elementos
                abarcarían todo el espacio disponible y en el momento en el que hay 200px libres se añade un elemento
            </p>
        </div>

        <center>
            <div class="container6">
                <div>1</div>
                <div>2</div>
                <div>3</div>
                <div>4</div>
                <div>5</div>
                <div>6</div>
                <div>7</div>
            </div>
        </center>

        <div>
            <h1>Conclusión</h1>
            <p>Como hemos visto con grid-template-areas, grid-template-rows y grid-template-columns podemos lograr
                maquetación en CSS de manera fácil y efectiva. Pero solamente hemos visto la punta del iceberg, puesto
                que CSS Grid trae consigo un montón más de funcionalidades y mejoras.</p>
            <p>Por ejemplo podemos tener control absoluto del alineamiento que toman todos los elementos dentro de la
                grilla tanto horizontalmente con justify-items como verticalmente con align-items. También disponemos
                con justify-content o align-content formas de alinear la grilla como tal en el eje X o el Y.</p>
        </div>
    </main>
</body>

</html>